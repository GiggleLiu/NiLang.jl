<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Manual · NiLang.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NiLang.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../why/">What and Why</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../tutorial/">My first NiLang program</a></li><li><a class="tocitem" href="../examples/port_zygote/">How to port NiLang to Zygote</a></li><li><a class="tocitem" href="../examples/port_chainrules/">How to port NiLang to ChainRules</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/fib/">Computing Fibonacci Numbers</a></li><li><a class="tocitem" href="../examples/pyramid/">Pyramid example</a></li><li><a class="tocitem" href="../examples/besselj/">Bessel function</a></li><li><a class="tocitem" href="../examples/sparse/">Sparse matrices</a></li><li><a class="tocitem" href="../examples/lognumber/">Logarithmic number system</a></li><li><a class="tocitem" href="../examples/unitary/">Unitary matrix operations without allocation</a></li><li><a class="tocitem" href="../examples/nice/">NICE network</a></li><li><a class="tocitem" href="../examples/realnvp/">RealNVP network</a></li><li><a class="tocitem" href="../examples/qr/">A simple QR decomposition</a></li><li><a class="tocitem" href="../examples/boxmuller/">Box-Muller method to Generate normal distribution</a></li></ul></li><li><span class="tocitem">API &amp; Manual</span><ul><li><a class="tocitem" href="../instructions/">Instruction Reference</a></li><li><a class="tocitem" href="../extend/">How to extend</a></li><li><a class="tocitem" href="../examples/sharedwrite/">The shared write problem on GPU</a></li><li class="is-active"><a class="tocitem" href>API Manual</a><ul class="internal"><li><a class="tocitem" href="#Compiling-Tools-(Reexported-from-NiLangCore)"><span>Compiling Tools (Reexported from NiLangCore)</span></a></li><li><a class="tocitem" href="#Instructions"><span>Instructions</span></a></li><li><a class="tocitem" href="#Automatic-Differentiation"><span>Automatic Differentiation</span></a></li></ul></li><li><a class="tocitem" href="../faq/">-</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API &amp; Manual</a></li><li class="is-active"><a href>API Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/GiggleLiu/NiLang.jl/blob/master/docs/src/api.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Manual"><a class="docs-heading-anchor" href="#API-Manual">API Manual</a><a id="API-Manual-1"></a><a class="docs-heading-anchor-permalink" href="#API-Manual" title="Permalink"></a></h1><h2 id="Compiling-Tools-(Reexported-from-NiLangCore)"><a class="docs-heading-anchor" href="#Compiling-Tools-(Reexported-from-NiLangCore)">Compiling Tools (Reexported from NiLangCore)</a><a id="Compiling-Tools-(Reexported-from-NiLangCore)-1"></a><a class="docs-heading-anchor-permalink" href="#Compiling-Tools-(Reexported-from-NiLangCore)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@assign" href="#NiLangCore.@assign"><code>NiLangCore.@assign</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@assign a b [invcheck]</code></pre><p>Perform the assign <code>a = b</code> in a reversible program. Turn off invertibility check if the <code>invcheck</code> is false.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@assignback" href="#NiLangCore.@assignback"><code>NiLangCore.@assignback</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@assignback f(args...) [invcheck]</code></pre><p>Assign input variables with output values: <code>args... = f(args...)</code>, turn off invertibility error check if the second argument is false.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@code_julia-Tuple{Any}" href="#NiLangCore.@code_julia-Tuple{Any}"><code>NiLangCore.@code_julia</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@code_julia ex</code></pre><p>Get the interpreted expression of <code>ex</code>.</p><pre><code class="language-julia hljs">julia&gt; @code_julia x += exp(3.0)
quote
    var&quot;##results#267&quot; = ((PlusEq)(exp))(x, 3.0)
    x = var&quot;##results#267&quot;[1]
    try
        (NiLangCore.deanc)(3.0, var&quot;##results#267&quot;[2])
    catch e
        @warn &quot;deallocate fail: `3.0 → var&quot;##results#267&quot;[2]`&quot;
        throw(e)
    end
end

julia&gt; @code_julia @invcheckoff x += exp(3.0)
quote
    var&quot;##results#257&quot; = ((PlusEq)(exp))(x, 3.0)
    x = var&quot;##results#257&quot;[1]
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@code_preprocess-Tuple{Any}" href="#NiLangCore.@code_preprocess-Tuple{Any}"><code>NiLangCore.@code_preprocess</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@code_preprocess ex</code></pre><p>Preprocess <code>ex</code> and return the symmetric reversible IR.</p><pre><code class="language-julia-repl hljs">julia&gt; NiLangCore.rmlines(@code_preprocess if (x &lt; 3, ~) x += exp(3.0) end)
:(if (x &lt; 3, x &lt; 3)
      x += exp(3.0)
  end)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@code_reverse-Tuple{Any}" href="#NiLangCore.@code_reverse-Tuple{Any}"><code>NiLangCore.@code_reverse</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@code_reverse ex</code></pre><p>Get the reversed expression of <code>ex</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; @code_reverse x += exp(3.0)
:(x -= exp(3.0))</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@dual-Tuple{Any, Any}" href="#NiLangCore.@dual-Tuple{Any, Any}"><code>NiLangCore.@dual</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@dual f invf</code></pre><p>Define <code>f</code> and <code>invf</code> as a pair of dual instructions, i.e. reverse to each other.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@fieldview-Tuple{Any}" href="#NiLangCore.@fieldview-Tuple{Any}"><code>NiLangCore.@fieldview</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@fieldview fname(x::TYPE) = x.fieldname
@fieldview fname(x::TYPE) = x[i]
...</code></pre><p>Create a function fieldview that can be accessed by a reversible program</p><pre><code class="language-julia-repl hljs">julia&gt; struct GVar{T, GT}
           x::T
           g::GT
       end

julia&gt; @fieldview xx(x::GVar) = x.x

julia&gt; chfield(GVar(1.0, 0.0), xx, 2.0)
GVar{Float64, Float64}(2.0, 0.0)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@i-Tuple{Any}" href="#NiLangCore.@i-Tuple{Any}"><code>NiLangCore.@i</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@i function fname(args..., kwargs...) ... end
@i struct sname ... end</code></pre><p>Define a reversible function/type.</p><pre><code class="language-julia-repl hljs">julia&gt; @i function test(out!, x)
           out! += identity(x)
       end

julia&gt; test(0.2, 0.8)
(1.0, 0.8)</code></pre><p>See <code>test/compiler.jl</code> for more examples.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@instr-Tuple{Any}" href="#NiLangCore.@instr-Tuple{Any}"><code>NiLangCore.@instr</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@instr ex</code></pre><p>Execute a reversible instruction.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@invcheck-Tuple{Any, Any}" href="#NiLangCore.@invcheck-Tuple{Any, Any}"><code>NiLangCore.@invcheck</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@invcheck x val</code></pre><p>The macro version <code>NiLangCore.deanc</code>, with more informative error.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@selfdual-Tuple{Any}" href="#NiLangCore.@selfdual-Tuple{Any}"><code>NiLangCore.@selfdual</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@selfdual f</code></pre><p>Define <code>f</code> as a self-dual instructions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.@with-Tuple{Any}" href="#NiLangCore.@with-Tuple{Any}"><code>NiLangCore.@with</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>e.g. <code>@with x.y = val</code> will return a new object similar to <code>x</code>, with the <code>y</code> field changed to <code>val</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore._zero-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#NiLangCore._zero-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>NiLangCore._zero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_zero(T)
_zero(x::T)</code></pre><p>Create a <code>zero</code> of type <code>T</code> by recursively applying <code>zero</code> to its fields.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.almost_same-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractFloat" href="#NiLangCore.almost_same-Union{Tuple{T}, Tuple{T, T}} where T&lt;:AbstractFloat"><code>NiLangCore.almost_same</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">almost_same(a, b; atol=GLOBAL_ATOL[], kwargs...) -&gt; Bool</code></pre><p>Return true if <code>a</code> and <code>b</code> are almost same w.r.t. <code>atol</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.assign_vars-Tuple{Any, Any, Any}" href="#NiLangCore.assign_vars-Tuple{Any, Any, Any}"><code>NiLangCore.assign_vars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">assign_vars(args, symres, invcheck)</code></pre><p>Get the expression of assigning <code>symres</code> to <code>args</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.check_inv-Tuple{Any, Any}" href="#NiLangCore.check_inv-Tuple{Any, Any}"><code>NiLangCore.check_inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_inv(f, args; atol::Real=1e-8, verbose::Bool=false, kwargs...)</code></pre><p>Return true if <code>f(args..., kwargs...)</code> is reversible.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.chfield" href="#NiLangCore.chfield"><code>NiLangCore.chfield</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">chfield(x, field, val)</code></pre><p>Change a <code>field</code> of an object <code>x</code>.</p><p>The <code>field</code> can be a <code>Val</code> type</p><pre><code class="language-julia-repl hljs">julia&gt; chfield(1+2im, Val(:im), 5)
1 + 5im</code></pre><p>or a function</p><pre><code class="language-julia-repl hljs">julia&gt; using NiLangCore

julia&gt; struct GVar{T, GT}
           x::T
           g::GT
       end

julia&gt; @fieldview xx(x::GVar) = x.x

julia&gt; chfield(GVar(1.0, 0.0), xx, 2.0)
GVar{Float64, Float64}(2.0, 0.0)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.compile_ex-Tuple{Module, Any, Any}" href="#NiLangCore.compile_ex-Tuple{Module, Any, Any}"><code>NiLangCore.compile_ex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compile_ex(m::Module, ex, info)</code></pre><p>Compile a NiLang statement to a regular julia statement.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.deanc" href="#NiLangCore.deanc"><code>NiLangCore.deanc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deanc(a, b)</code></pre><p>Deallocate varialbe <code>a</code> with value <code>b</code>. It will throw an error if</p><ul><li><code>a</code> and <code>b</code> are objects with different types,</li><li><code>a</code> is not equal to <code>b</code> (for floating point numbers, an error within <code>NiLangCore.GLOBAL_ATOL[]</code> is allowed),</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.dual_ex-Tuple{Module, Any}" href="#NiLangCore.dual_ex-Tuple{Module, Any}"><code>NiLangCore.dual_ex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dual_ex(m::Module, ex)</code></pre><p>Get the dual expression of <code>ex</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.get_argname-Tuple{Any}" href="#NiLangCore.get_argname-Tuple{Any}"><code>NiLangCore.get_argname</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_argname(ex)</code></pre><p>Return the argument name of a function argument expression, e.g. <code>x::Float64 = 4</code> gives <code>x</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.get_ftype-Tuple{Any}" href="#NiLangCore.get_ftype-Tuple{Any}"><code>NiLangCore.get_ftype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_ftype(fname)</code></pre><p>Return the function type, e.g.</p><ul><li><code>obj::ABC</code> =&gt; <code>ABC</code></li><li><code>f</code> =&gt; <code>typeof(f)</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.isprimitive-Tuple{Any}" href="#NiLangCore.isprimitive-Tuple{Any}"><code>NiLangCore.isprimitive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isprimitive(f)</code></pre><p>Return <code>true</code> if <code>f</code> is an <code>instruction</code> that can not be decomposed anymore.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.isreflexive-Tuple{Any}" href="#NiLangCore.isreflexive-Tuple{Any}"><code>NiLangCore.isreflexive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isreflexive(f)</code></pre><p>Return <code>true</code> if a function is self-inverse.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.isreversible-Union{Tuple{ARGT}, Tuple{Any, Type{ARGT}}} where ARGT" href="#NiLangCore.isreversible-Union{Tuple{ARGT}, Tuple{Any, Type{ARGT}}} where ARGT"><code>NiLangCore.isreversible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isreversible(f, ARGT)</code></pre><p>Return <code>true</code> if a function is reversible.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.loaddata-Union{Tuple{T}, Tuple{Type{T}, T}} where T" href="#NiLangCore.loaddata-Union{Tuple{T}, Tuple{Type{T}, T}} where T"><code>NiLangCore.loaddata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loaddata(t, x)</code></pre><p>load data <code>x</code>, matching type <code>t</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.match_function-Tuple{Any}" href="#NiLangCore.match_function-Tuple{Any}"><code>NiLangCore.match_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">match_function(ex)</code></pre><p>Analyze a function expression, returns a tuple of <code>(macros, function name, arguments, type parameters (in where {...}), statements in the body)</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.nilang_ir-Tuple{Module, Any}" href="#NiLangCore.nilang_ir-Tuple{Module, Any}"><code>NiLangCore.nilang_ir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nilang_ir(ex; reversed::Bool=false)</code></pre><p>Get the NiLang reversible IR from the function expression <code>ex</code>, return the reversed function if <code>reversed</code> is <code>true</code>.</p><p>This IR is not directly executable on Julia, please use <code>macroexpand(Main, :(@i function .... end))</code> to get the julia expression of a reversible function.</p><pre><code class="language-julia-repl hljs">julia&gt; ex = :(@inline function f(x!::T, y) where T
                @routine begin
                    anc ← zero(T)
                    anc += identity(x!)
                end
                x! += y * anc
                ~@routine
           end);

julia&gt; NiLangCore.nilang_ir(Main, ex) |&gt; NiLangCore.rmlines
:(@inline function f(x!::T, y) where T
          begin
              anc ← zero(T)
              anc += identity(x!)
          end
          x! += y * anc
          begin
              anc -= identity(x!)
              anc → zero(T)
          end
      end)

julia&gt; NiLangCore.nilang_ir(Main, ex; reversed=true) |&gt; NiLangCore.rmlines
:(@inline function (~f)(x!::T, y) where T
          begin
              anc ← zero(T)
              anc += identity(x!)
          end
          x! -= y * anc
          begin
              anc -= identity(x!)
              anc → zero(T)
          end
      end)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.precom-Tuple{Module, Any}" href="#NiLangCore.precom-Tuple{Module, Any}"><code>NiLangCore.precom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">precom(module, ex)</code></pre><p>Precompile a function, returns a tuple of (macros, function name, arguments, type parameters, function body).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.precom_ex-Tuple{Module, Any, Any}" href="#NiLangCore.precom_ex-Tuple{Module, Any, Any}"><code>NiLangCore.precom_ex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">precom_ex(module, ex, info)</code></pre><p>Precompile a single statement <code>ex</code>, where <code>info</code> is a <code>PreInfo</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.protectf-Tuple{Any}" href="#NiLangCore.protectf-Tuple{Any}"><code>NiLangCore.protectf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">protectf(f)</code></pre><p>Protect a function from being inverted, useful when using an callable object.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.rmlines-Tuple{Expr}" href="#NiLangCore.rmlines-Tuple{Expr}"><code>NiLangCore.rmlines</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rmlines(ex::Expr)</code></pre><p>Remove line number nodes for pretty printing.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.subarray-Tuple" href="#NiLangCore.subarray-Tuple"><code>NiLangCore.subarray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subarray(ranges...)</code></pre><p>Get a subarray, same as <code>view</code> in Base.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.tget-Tuple{Int64}" href="#NiLangCore.tget-Tuple{Int64}"><code>NiLangCore.tget</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tget(i::Int)</code></pre><p>Get the i-th entry of a tuple.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.unzipped_broadcast-Tuple{Any}" href="#NiLangCore.unzipped_broadcast-Tuple{Any}"><code>NiLangCore.unzipped_broadcast</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unzipped_broadcast(f, args...)</code></pre><p>unzipped broadcast for arrays and tuples, e.g. <code>SWAP.([1,2,3], [4,5,6])</code> will do inplace element-wise swap, and return <code>[4,5,6], [1,2,3]</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.DivEq" href="#NiLangCore.DivEq"><code>NiLangCore.DivEq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DivEq{FT} &lt;: Function
DivEq(f)</code></pre><p>Called when executing <code>out /= f(args...)</code> instruction. See <code>PlusEq</code> for detail.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.Inv" href="#NiLangCore.Inv"><code>NiLangCore.Inv</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Inv{FT} &lt;: Function
Inv(f)</code></pre><p>The inverse of a function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.InvertibilityError" href="#NiLangCore.InvertibilityError"><code>NiLangCore.InvertibilityError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InvertibilityError &lt;: Exception
InvertibilityError(ex)</code></pre><p>The error for irreversible statements.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.MinusEq" href="#NiLangCore.MinusEq"><code>NiLangCore.MinusEq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MinusEq{FT} &lt;: Function
MinusEq(f)</code></pre><p>Called when executing <code>out -= f(args...)</code> instruction. See <code>PlusEq</code> for detail.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.MulEq" href="#NiLangCore.MulEq"><code>NiLangCore.MulEq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MulEq{FT} &lt;: Function
MulEq(f)</code></pre><p>Called when executing <code>out *= f(args...)</code> instruction. See <code>PlusEq</code> for detail.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.PlusEq" href="#NiLangCore.PlusEq"><code>NiLangCore.PlusEq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PlusEq{FT} &lt;: Function
PlusEq(f)</code></pre><p>Called when executing <code>out += f(args...)</code> instruction. The following two statements are same</p><pre><code class="language-julia-repl hljs">julia&gt; x, y, z = 0.0, 2.0, 3.0
(0.0, 2.0, 3.0)

julia&gt; x, y, z = PlusEq(*)(x, y, z)
(6.0, 2.0, 3.0)

julia&gt; x, y, z = 0.0, 2.0, 3.0
(0.0, 2.0, 3.0)

julia&gt; @instr x += y*z


julia&gt; x, y, z
(6.0, 2.0, 3.0)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLangCore.XorEq" href="#NiLangCore.XorEq"><code>NiLangCore.XorEq</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">XorEq{FT} &lt;: Function
XorEq(f)</code></pre><p>Called when executing <code>out ⊻= f(args...)</code> instruction. See <code>PlusEq</code> for detail.</p></div></section></article><h2 id="Instructions"><a class="docs-heading-anchor" href="#Instructions">Instructions</a><a id="Instructions-1"></a><a class="docs-heading-anchor-permalink" href="#Instructions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NiLang.@zeros-Tuple{Any, Vararg{Any}}" href="#NiLang.@zeros-Tuple{Any, Vararg{Any}}"><code>NiLang.@zeros</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Create zeros of specific type.</p><pre><code class="language-julia hljs">julia&gt; @i function f(x)
           @zeros Float64 a b c
           # do something
       end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/vars.jl#LL4-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.DEC-Tuple{Number}" href="#NiLang.DEC-Tuple{Number}"><code>NiLang.DEC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DEC(a!) -&gt; a! - 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/instructs.jl#LL40-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.HADAMARD-Tuple{Real, Real}" href="#NiLang.HADAMARD-Tuple{Real, Real}"><code>NiLang.HADAMARD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HADAMARD(x::Real, y::Real)</code></pre><p>Hadamard transformation that returns <code>(x + y)/√2, (x - y)/√2</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/instructs.jl#LL87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.INC-Tuple{Number}" href="#NiLang.INC-Tuple{Number}"><code>NiLang.INC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">INC(a!) -&gt; a! + 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/instructs.jl#LL33-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.IROT-Tuple{Real, Real, Real}" href="#NiLang.IROT-Tuple{Real, Real, Real}"><code>NiLang.IROT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">IROT(a!, b!, θ) -&gt; ROT(a!, b!, -θ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/instructs.jl#LL78-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.ROT-Tuple{Real, Real, Real}" href="#NiLang.ROT-Tuple{Real, Real, Real}"><code>NiLang.ROT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ROT(a!, b!, θ) -&gt; a!&#39;, b!&#39;, θ</code></pre><p class="math-container">\[\begin{align}
    {\rm ROT}(a!, b!, \theta)  = \begin{bmatrix}
        \cos(\theta) &amp; - \sin(\theta)\\
        \sin(\theta)  &amp; \cos(\theta)
    \end{bmatrix}
    \begin{bmatrix}
        a!\\
        b!
    \end{bmatrix},
\end{align}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/instructs.jl#LL57-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.SWAP-Union{Tuple{T}, Tuple{T, T}} where T" href="#NiLang.SWAP-Union{Tuple{T}, Tuple{T, T}} where T"><code>NiLang.SWAP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SWAP(a!, b!) -&gt; b!, a!</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/instructs.jl#LL49-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.alloc" href="#NiLang.alloc"><code>NiLang.alloc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">alloc(f, args...)</code></pre><p>allocate function output space (the first argument), where <code>args</code> only contains the last <code>N-1</code> arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/macros.jl#LL4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.arshift-Union{Tuple{T}, Tuple{T, Any}} where T" href="#NiLang.arshift-Union{Tuple{T}, Tuple{T, Any}} where T"><code>NiLang.arshift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">arshift(x, n)</code></pre><p>right shift, sign extending.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/utils.jl#LL27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.bennett!-Union{Tuple{T}, Tuple{Any, Dict{Int64, T}, Vararg{Any}}} where T" href="#NiLang.bennett!-Union{Tuple{T}, Tuple{Any, Dict{Int64, T}, Vararg{Any}}} where T"><code>NiLang.bennett!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bennett!(step, state::Dict, args...; k, N, logger=BennettLog(), do_uncomputing=false, kwargs...)</code></pre><ul><li><code>step</code> is a reversible step function,</li><li><code>state</code> is the dictionary state, with <code>state[1]</code> the input state, the return value is stored in <code>state[N+1]</code>,</li><li><code>k</code> is the number of steps in each Bennett&#39;s recursion,</li><li><code>N</code> is the total number of steps,</li><li><code>logger=BennettLog()</code> is the logging of Bennett&#39;s algorithm,</li><li><code>args...</code> and <code>kwargs...</code> are additional arguments for steps.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/bennett.jl#LL65-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.bennett-Union{Tuple{T}, Tuple{Any, T, T, Vararg{Any}}} where T" href="#NiLang.bennett-Union{Tuple{T}, Tuple{Any, T, T, Vararg{Any}}} where T"><code>NiLang.bennett</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bennett(step, y, x, args...; k, N, logger=BennettLog(), kwargs...)</code></pre><ul><li><code>step</code> is a reversible step function,</li><li><code>y</code> is the output state,</li><li><code>x</code> is the input state,</li><li><code>k</code> is the number of steps in each Bennett&#39;s recursion,</li><li><code>N</code> is the total number of steps,</li><li><code>logger=BennettLog()</code> is the logging of Bennett&#39;s algorithm,</li><li><code>args...</code> and <code>kwargs...</code> are additional arguments for steps.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/bennett.jl#LL42-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.i_affine!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, AbstractVector{T}, AbstractVector{T}}} where T" href="#NiLang.i_affine!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, AbstractVector{T}, AbstractVector{T}}} where T"><code>NiLang.i_affine!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">i_affine!(y!, W, b, x)</code></pre><p><code>affine!</code> transformation <code>y! += W*x + b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/linalg.jl#LL56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.i_ascending!-Union{Tuple{T}, Tuple{AbstractVector{T}, Any, AbstractArray{T}}} where T" href="#NiLang.i_ascending!-Union{Tuple{T}, Tuple{AbstractVector{T}, Any, AbstractArray{T}}} where T"><code>NiLang.i_ascending!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">i_ascending!(xs!, inds!, arr)</code></pre><p>Find the ascending sequence in <code>arr</code> and store the results into <code>xs!</code>, indices are stored in <code>inds!</code>. This function can be used to get the maximum value and maximum indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/sorting.jl#LL3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.i_axpy!-Tuple{Any, Any, Any}" href="#NiLang.i_axpy!-Tuple{Any, Any, Any}"><code>NiLang.i_axpy!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">i_axpy!(a, x, y!)</code></pre><p>compute <code>y! += a * x</code>, where <code>x</code> and <code>y</code> are vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/blas.jl#LL68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.i_cor_cov-Union{Tuple{T}, Tuple{T, T, AbstractVector{T}, AbstractVector{T}}} where T" href="#NiLang.i_cor_cov-Union{Tuple{T}, Tuple{T, T, AbstractVector{T}, AbstractVector{T}}} where T"><code>NiLang.i_cor_cov</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> i_cor_cov(rho!,cov!,a,b)</code></pre><p>get Pearson correlation and covariance of two vectors <code>a</code> and <code>b</code> </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/statistics.jl#LL72-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.i_dirtymul-Tuple{Any, Any, Any}" href="#NiLang.i_dirtymul-Tuple{Any, Any, Any}"><code>NiLang.i_dirtymul</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">i_dirtymul(out!, x, anc!)</code></pre><p>&quot;dirty&quot; reversible multiplication that computes <code>out! *= x</code> approximately for floating point numbers, the <code>anc!</code> is anticipated as a number ~0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/base.jl#LL16-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.i_factorial-Tuple{Int64, Int64}" href="#NiLang.i_factorial-Tuple{Int64, Int64}"><code>NiLang.i_factorial</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">i_factorial(out!, n)</code></pre><p>Compute the factorial <code>out! = factorial(n)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/base.jl#LL34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.i_filter!-Union{Tuple{T}, Tuple{Any, AbstractVector, AbstractVector{T}}} where T" href="#NiLang.i_filter!-Union{Tuple{T}, Tuple{Any, AbstractVector, AbstractVector{T}}} where T"><code>NiLang.i_filter!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">i_filter!(f, out!, iter)</code></pre><p>Reversible <code>filter</code> function, <code>out!</code> is an emptied vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/mapreduce.jl#LL18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.i_inv!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where T" href="#NiLang.i_inv!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}}} where T"><code>NiLang.i_inv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">i_inv!(out!, A)</code></pre><p>Get the inverse of <code>A</code>.</p><pre><code class="language-note hljs">this function is implemented as a primitive.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/linalg.jl#LL3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.i_logsumexp-Union{Tuple{T}, Tuple{Any, Any, Any, Any, AbstractArray{T}}} where T" href="#NiLang.i_logsumexp-Union{Tuple{T}, Tuple{Any, Any, Any, Any, AbstractArray{T}}} where T"><code>NiLang.i_logsumexp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">i_logsumexp(logout!, out!, xs!, inds!, x)</code></pre><p>Compute <code>logout! = log(sum(exp(x)))</code>.</p><p><strong>Arguments</strong></p><pre><code class="nohighlight hljs">* `out!`, output,
* `logout!`, logged output,
* `xs!`, an empty vector to cache the ascending values (same type as `x`),
* `inds!`, an empty vector to cache the ascending indices (integer type),
* `x`, input vector.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/nnlib.jl#LL54-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.i_mapfoldl-Union{Tuple{T}, Tuple{Any, Any, T, Any}} where T" href="#NiLang.i_mapfoldl-Union{Tuple{T}, Tuple{Any, Any, T, Any}} where T"><code>NiLang.i_mapfoldl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">i_mapfoldl(map, fold, out!, iter)</code></pre><p>Reversible <code>mapfoldl</code> function, <code>map</code> can be irreversible, but <code>fold</code> should be reversible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/mapreduce.jl#LL3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.i_mean_sum-Tuple{Any, Any, Any}" href="#NiLang.i_mean_sum-Tuple{Any, Any, Any}"><code>NiLang.i_mean_sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">i_mean_sum(out!, sum!, x)</code></pre><p>get the <code>mean</code> and <code>sum</code> of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/statistics.jl#LL4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.i_mul!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}}} where T" href="#NiLang.i_mul!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}}} where T"><code>NiLang.i_mul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">i_mul!(out!, x, y)</code></pre><p>compute <code>x * y</code> (<code>x</code> and <code>y</code> are matrices, and store results in <code>out!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/blas.jl#LL20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.i_norm2-Tuple{Any, Any}" href="#NiLang.i_norm2-Tuple{Any, Any}"><code>NiLang.i_norm2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">i_norm2(out!, x)</code></pre><p>get the squared norm of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/blas.jl#LL57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.i_normal_logpdf-Union{Tuple{T}, Tuple{Any, T, Any, Any}} where T" href="#NiLang.i_normal_logpdf-Union{Tuple{T}, Tuple{Any, T, Any, Any}} where T"><code>NiLang.i_normal_logpdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">i_normal_logpdf(out, x, μ, σ)</code></pre><p>get the pdf of <code>Normal(μ, σ)</code> at point <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/statistics.jl#LL51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.i_relu-Tuple{Any, Any}" href="#NiLang.i_relu-Tuple{Any, Any}"><code>NiLang.i_relu</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">i_relu(out!, x)</code></pre><p>ReLU in machine learning.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/nnlib.jl#LL43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.i_softmax_crossentropy-Union{Tuple{T}, Tuple{Any, Any, Any, Any, Any, T}} where T" href="#NiLang.i_softmax_crossentropy-Union{Tuple{T}, Tuple{Any, Any, Any, Any, Any, T}} where T"><code>NiLang.i_softmax_crossentropy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">i_softmax_crossentropy(x, p, imax, xmax, Z, out)</code></pre><p>Softmax-Cross entropy function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/nnlib.jl#LL14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.i_sqdistance-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, AbstractVector}} where T" href="#NiLang.i_sqdistance-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, AbstractVector}} where T"><code>NiLang.i_sqdistance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">i_sqdistance(dist!, x1, x2)</code></pre><p>Squared distance between two points <code>x1</code> and <code>x2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/base.jl#LL3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.i_sum-Tuple{Any, AbstractArray}" href="#NiLang.i_sum-Tuple{Any, AbstractArray}"><code>NiLang.i_sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">i_sum(out!, x)</code></pre><p>get the sum of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/blas.jl#LL3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.i_umm!-Tuple{AbstractArray, Any}" href="#NiLang.i_umm!-Tuple{AbstractArray, Any}"><code>NiLang.i_umm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">i_umm!(x!, θ)</code></pre><p>Compute unitary matrix multiplication on <code>x</code>, where the unitary matrix is parameterized by (N+1)*N/2 <code>θ</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/blas.jl#LL80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.i_var_mean_sum-Union{Tuple{T}, Tuple{VarianceInfo{T}, AbstractVector{T}}} where T" href="#NiLang.i_var_mean_sum-Union{Tuple{T}, Tuple{VarianceInfo{T}, AbstractVector{T}}} where T"><code>NiLang.i_var_mean_sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">i_var_mean_sum(varinfo, sqv)
i_var_mean_sum(var!, varsum!, mean!, sum!, v)</code></pre><p>Compute the variance, the accumulated variance, mean and sum. <code>varinfo</code> is the <code>VarianceInfo</code> object to store outputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/stdlib/statistics.jl#LL27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.plshift-Tuple{Any, Any}" href="#NiLang.plshift-Tuple{Any, Any}"><code>NiLang.plshift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plshift(x, n)</code></pre><p>periodic left shift.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/utils.jl#LL13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.prshift-Tuple{Any, Any}" href="#NiLang.prshift-Tuple{Any, Any}"><code>NiLang.prshift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plshift(x, n)</code></pre><p>periodic right shift.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/utils.jl#LL20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.rot-Tuple{Any, Any, Any}" href="#NiLang.rot-Tuple{Any, Any, Any}"><code>NiLang.rot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rot(a, b, θ)</code></pre><p>rotate variables <code>a</code> and <code>b</code> by an angle <code>θ</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/utils.jl#LL3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.unwrap-Tuple{IWrapper}" href="#NiLang.unwrap-Tuple{IWrapper}"><code>NiLang.unwrap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unwrap(x)</code></pre><p>Unwrap a wrapper instance (recursively) to get the content value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/wrappers.jl#LL21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.value-Tuple{Any}" href="#NiLang.value-Tuple{Any}"><code>NiLang.value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">value(x)</code></pre><p>Get the <code>value</code> from a wrapper instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/wrappers.jl#LL3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.AutoBcast" href="#NiLang.AutoBcast"><code>NiLang.AutoBcast</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AutoBcast{T,N} &lt;: IWrapper{T}</code></pre><p>A vectorized variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/autobcast.jl#LL3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.IWrapper" href="#NiLang.IWrapper"><code>NiLang.IWrapper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IWrapper{T} &lt;: Real</code></pre><p>IWrapper{T} is a wrapper of for data of type T. It will forward <code>&gt;, &lt;, &gt;=, &lt;=, ≈</code> operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/wrappers.jl#LL11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.NoGrad" href="#NiLang.NoGrad"><code>NiLang.NoGrad</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoGrad{T} &lt;: IWrapper{T}
NoGrad(x)</code></pre><p>A <code>NoGrad(x)</code> is equivalent to <code>GVar^{-1}(x)</code>, which cancels the <code>GVar</code> wrapper.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/instructs.jl#LL7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.Partial" href="#NiLang.Partial"><code>NiLang.Partial</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Partial{FIELD, T, T2} &lt;: IWrapper{T2}</p><p>Take a field <code>FIELD</code> without dropping information. This operation can be undone by calling <code>~Partial{FIELD}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/wrappers.jl#LL37-L42">source</a></section></article><h2 id="Automatic-Differentiation"><a class="docs-heading-anchor" href="#Automatic-Differentiation">Automatic Differentiation</a><a id="Automatic-Differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Differentiation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NiLang.AD.@nograd-Tuple{Any}" href="#NiLang.AD.@nograd-Tuple{Any}"><code>NiLang.AD.@nograd</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@nograd f(args...)</code></pre><p>Mark <code>f(args...)</code> as having no gradients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/autodiff/vars.jl#LL193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.AD.check_grad-Tuple{Any, Any}" href="#NiLang.AD.check_grad-Tuple{Any, Any}"><code>NiLang.AD.check_grad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_grad(f, args; atol::Real=1e-8, verbose::Bool=false, iloss::Int, kwargs...)</code></pre><p>Return true if the gradient of <code>f(args..., kwargs...)</code> is reversible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/autodiff/checks.jl#LL103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.AD.grad-Tuple{NiLang.AD.GVar}" href="#NiLang.AD.grad-Tuple{NiLang.AD.GVar}"><code>NiLang.AD.grad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grad(var)</code></pre><p>Get the gradient field of <code>var</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/autodiff/vars.jl#LL130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.AD.gradient_numeric-Tuple{Any, Any}" href="#NiLang.AD.gradient_numeric-Tuple{Any, Any}"><code>NiLang.AD.gradient_numeric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradient_numeric(f, args...; iloss, kwargs...)</code></pre><p>Numeric differentiating f(args..., kwargs...).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/autodiff/checks.jl#LL88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.AD.hessian_backback-Tuple{Any, Any}" href="#NiLang.AD.hessian_backback-Tuple{Any, Any}"><code>NiLang.AD.hessian_backback</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hessian_backback(f, args; iloss::Int, kwargs...)</code></pre><p>Obtain the Hessian matrix of <code>f(args..., kwargs...)</code> by back propagating adjoint program.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/autodiff/hessian_backback.jl#LL16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.AD.jacobian-Tuple{Any, Vararg{Any}}" href="#NiLang.AD.jacobian-Tuple{Any, Vararg{Any}}"><code>NiLang.AD.jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jacobian(f, args...; iin::Int, iout::Int=iin, kwargs...)</code></pre><p>Get the Jacobian matrix for function <code>f(args..., kwargs...)</code> using vectorized variables in the gradient field. One can use key word arguments <code>iin</code> and <code>iout</code> to specify the input and output tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/autodiff/jacobian.jl#LL27-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.AD.jacobian_repeat-Tuple{Any, Vararg{Any}}" href="#NiLang.AD.jacobian_repeat-Tuple{Any, Vararg{Any}}"><code>NiLang.AD.jacobian_repeat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jacobian_repeat(f, args...; iin::Int, iout::Int=iin, kwargs...)</code></pre><p>Get the Jacobian matrix for function <code>f(args..., kwargs...)</code> using repeated computing gradients for each output. One can use key word arguments <code>iin</code> and <code>iout</code> to specify the input and output tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/autodiff/jacobian.jl#LL5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.AD.GVar" href="#NiLang.AD.GVar"><code>NiLang.AD.GVar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GVar{T,GT} &lt;: IWrapper{T}
GVar(x)</code></pre><p>Add gradient information to variable <code>x</code>, where <code>x</code> can be a real number or a general structure. If it is a non-integer real number, it will wrap the element with a gradient field, otherwise it will propagate into the type and wrap the elements with <code>GVar</code>. Runing a program backward will update the gradient fields of <code>GVar</code>s. The following is a toy using case.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NiLang.AD: GVar, grad

julia&gt; struct A{T}
           x::T
       end

julia&gt; GVar(A(2.0+3im), A(3.0+3im))
A{Complex{GVar{Float64, Float64}}}(GVar(2.0, 3.0) + GVar(3.0, 3.0)*im)

julia&gt; @i function f(a::A, b::A)
           a.x += log(b.x)
       end

julia&gt; outputs = f(A(2.0+3im), A(2.0-1im))  # forward pass
(A{ComplexF64}(2.8047189562170503 + 2.536352390999194im), A{ComplexF64}(2.0 - 1.0im))

julia&gt; outputs_with_gradients = (GVar(outputs[1], A(3.0+3im)), GVar(outputs[2]))  # wrap `GVar`
(A{Complex{GVar{Float64, Float64}}}(GVar(2.8047189562170503, 3.0) + GVar(2.536352390999194, 3.0)*im), A{Complex{GVar{Float64, Float64}}}(GVar(2.0, 0.0) - GVar(1.0, -0.0)*im))

julia&gt; inputs_with_gradients = (~f)(outputs_with_gradients...)  # backward pass
(A{Complex{GVar{Float64, Float64}}}(GVar(2.0, 3.0) + GVar(3.0, 3.0)*im), A{Complex{GVar{Float64, Float64}}}(GVar(2.0, 1.8) - GVar(1.0, -0.6000000000000002)*im))

julia&gt; grad(inputs_with_gradients)
(A{ComplexF64}(3.0 + 3.0im), A{ComplexF64}(1.8 + 0.6000000000000002im))</code></pre><p>The outputs of <code>~f</code> are gradients for input variables, one can use <code>grad</code> to take the gradient fields recursively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/autodiff/vars.jl#LL2-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NiLang.AD.NGrad" href="#NiLang.AD.NGrad"><code>NiLang.AD.NGrad</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NGrad{N,FT} &lt;: Function</code></pre><p>Obtain gradients <code>Grad(f)(Val(i), args..., kwargs...)</code>, where <code>i</code> is the index of loss in <code>args</code>. <code>Grad</code> object calls forward first, and then backward.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>Val(1)</code> is specially optimized, so putting the loss as the first parameter can avoid potential overhead.</p></div></div><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GiggleLiu/NiLang.jl/blob/9f7edcf0c3cefe743332110d13932703d9c3c627/src/autodiff/gradfunc.jl#LL3-L11">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/sharedwrite/">« The shared write problem on GPU</a><a class="docs-footer-nextpage" href="../faq/">- »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Tuesday 22 March 2022 20:51">Tuesday 22 March 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
