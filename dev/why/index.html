<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>What and Why · NiLang.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">NiLang.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>What and Why</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#What-are-reversible-computing-and-reversible-programming"><span>What are reversible computing and reversible programming</span></a></li><li><a class="tocitem" href="#Why-reversible-computing-is-the-future-of-computing:-from-a-physicist&#39;s-perspective"><span>Why reversible computing is the future of computing: from a physicist&#39;s perspective</span></a></li></ul></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../tutorial/">My first NiLang program</a></li><li><a class="tocitem" href="../examples/port_zygote/">How to port NiLang to Zygote</a></li><li><a class="tocitem" href="../examples/port_chainrules/">How to port NiLang to ChainRules</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/fib/">Computing Fibonacci Numbers</a></li><li><a class="tocitem" href="../examples/pyramid/">Pyramid example</a></li><li><a class="tocitem" href="../examples/besselj/">Bessel function</a></li><li><a class="tocitem" href="../examples/sparse/">Sparse matrices</a></li><li><a class="tocitem" href="../examples/lognumber/">Logarithmic number system</a></li><li><a class="tocitem" href="../examples/unitary/">Unitary matrix operations without allocation</a></li><li><a class="tocitem" href="../examples/nice/">NICE network</a></li><li><a class="tocitem" href="../examples/realnvp/">RealNVP network</a></li><li><a class="tocitem" href="../examples/qr/">A simple QR decomposition</a></li><li><a class="tocitem" href="../examples/boxmuller/">Box-Muller method to Generate normal distribution</a></li></ul></li><li><span class="tocitem">API &amp; Manual</span><ul><li><a class="tocitem" href="../instructions/">Instruction Reference</a></li><li><a class="tocitem" href="../extend/">How to extend</a></li><li><a class="tocitem" href="../examples/sharedwrite/">The shared write problem on GPU</a></li><li><a class="tocitem" href="../api/">API Manual</a></li><li><a class="tocitem" href="../faq/">-</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>What and Why</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>What and Why</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/GiggleLiu/NiLang.jl/blob/master/docs/src/why.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="What-is-Reversible-Computing-and-why-do-we-need-it"><a class="docs-heading-anchor" href="#What-is-Reversible-Computing-and-why-do-we-need-it">What is Reversible Computing and why do we need it</a><a id="What-is-Reversible-Computing-and-why-do-we-need-it-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-Reversible-Computing-and-why-do-we-need-it" title="Permalink"></a></h1><h1 id="What-are-reversible-computing-and-reversible-programming"><a class="docs-heading-anchor" href="#What-are-reversible-computing-and-reversible-programming">What are reversible computing and reversible programming</a><a id="What-are-reversible-computing-and-reversible-programming-1"></a><a class="docs-heading-anchor-permalink" href="#What-are-reversible-computing-and-reversible-programming" title="Permalink"></a></h1><p>Reversible computing is a computing paradigm that can deterministically undo a computational process, it requires a user not erasing any information during computations. It boomed during 1970-2005, however, but runs into a winter after that. It can do anything that a traditional computing device can do, with possible overheads in time and space. Reversible programing is often considered as the computing model designed for reversible computing, while it can also be executed on a irreversible device. The following book covers a lot about reversible programming.</p><p><img src="../asset/revcomp.jpg" alt="Introduction to Reversible Computing"/></p><h2 id="Why-reversible-computing-is-the-future-of-computing:-from-a-physicist&#39;s-perspective"><a class="docs-heading-anchor" href="#Why-reversible-computing-is-the-future-of-computing:-from-a-physicist&#39;s-perspective">Why reversible computing is the future of computing: from a physicist&#39;s perspective</a><a id="Why-reversible-computing-is-the-future-of-computing:-from-a-physicist&#39;s-perspective-1"></a><a class="docs-heading-anchor-permalink" href="#Why-reversible-computing-is-the-future-of-computing:-from-a-physicist&#39;s-perspective" title="Permalink"></a></h2><p>The driving force of studying reversible computing is improving the energy efficiency of our computing devices. Energy efficiency of computing devices affect the value of <a href="https://www.investopedia.com/news/do-bitcoin-mining-energy-costs-influence-its-price/">bitcoins</a>, the battery size of a <a href="https://ieeexplore.ieee.org/document/7945170">spacecraft</a> and artificial intelligence (AI) industry as we will cover bellow.</p><p>As is well know, the fundamental laws of physics are reversible. Have you ever had such a confusion that why our computing model is irreversible while our world is governed by reversible laws? This discrepency is due to the fact that the irreversibility is an emergent phenomenon of statistic physics, we need a ideal heat bath that having an &quot;infinite size&quot; to create irreversibility. This is why the energy efficiency of traditional devices is getting harder and harder to improve, although they are still several orders above the Landauer&#39;s limit. The <a href="https://en.wikipedia.org/wiki/Landauer%27s_principle">Landauer&#39;s principle</a> states that irreversible computing has a lower bound of energy cost ~<span>$\ln 2 k_b T$</span></p><blockquote><p>Landauer&#39;s principle is a physical principle pertaining to the lower theoretical limit of energy consumption of computation. It holds that &quot;any logically irreversible manipulation of information, such as the erasure of a bit or the merging of two computation paths, must be accompanied by a corresponding entropy increase in non-information-bearing degrees of freedom of the information-processing apparatus or its environment&quot;.Another way of phrasing Landauer&#39;s principle is that if an observer loses information about a physical system, the observer loses the ability to extract work from that system.</p></blockquote><p>Microscopic systems that can be used to build up a reversible computing device are ubiquitous, like <a href="https://ieeexplore.ieee.org/abstract/document/8990955">fluxon</a>, cold atoms, <a href="https://www.amazon.com/Feynman-Lectures-Computation-Frontiers-Physics/dp/0738202967">DNA</a> and quantum dots. Even the adiabatic CMOS (a reversible computing device utilizing CMOS technology) can potentially be orders more energy efficient than traditional CMOS, and it is <a href="https://www.osti.gov/servlets/purl/1377599">already useful in spacecrafts</a>. The detailed analysis of the energy-speed trade off in adiabatic CMOS can be found <a href="https://www3.nd.edu/~lent/pdf/nd/AdiabaticCMOS_HanninenSniderLent2014.pdf">here</a>.</p><p>In reversible programming, <a href="https://arxiv.org/abs/2003.04617">automatically differentiating any program is directly achievable</a>. Automatic differentiation is a building block of artificial intelligence, crunching this problem can potentially lead to the next boom of AI. Programs are built on top of basic instructions like &quot;+&quot;, &quot;*&quot;, &quot;/&quot;, &quot;-&quot;. We can use these basic instructions to write Bessel functions, singular value decompositions et. al.  <a href="https://epubs.siam.org/doi/book/10.1137/1.9780898717761">Traditional autodiff frameworks</a> keep track of intermediate states in a global stack and use them for back-propagation. However, doing this brings space overheads that linear to time, which can easily explode the memory. Reversible programming reverse the tape directly for you, while having flexible yet efficient time-space tradeoff algorithms to control the memory usage.</p><p>I am optimistic about reversible computing also because we have so much room to improve in the energy perspective. Our computer computes one bit information at the energy cost ~<span>$10^8 k_b T$</span>, while in our body, DNA copy machine computes a bit information at an energy cost ~<span>$10 k_b T$</span>. To embrace the true artificial intelligence, we still have a long way to go.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../tutorial/">My first NiLang program »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 7 June 2021 20:20">Monday 7 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
