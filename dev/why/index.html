<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>What and Why · NiLang.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">NiLang.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>What and Why</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#what-is-reversible-computing"><span>what is reversible computing</span></a></li><li><a class="tocitem" href="#Why-reversible-computing-is-the-future-of-computing:-a-physicist&#39;s-perspective"><span>Why reversible computing is the future of computing: a physicist&#39;s perspective</span></a></li><li><a class="tocitem" href="#From-the-artificial-intelligence-perspective"><span>From the artificial intelligence perspective</span></a></li><li><a class="tocitem" href="#Embrace-Reversible-Computing:-Software-goes-first"><span>Embrace Reversible Computing: Software goes first</span></a></li><li><a class="tocitem" href="#FAQ"><span>FAQ</span></a></li></ul></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../tutorial/">My first NiLang program</a></li><li><a class="tocitem" href="../examples/port_zygote/">How to port NiLang to Zygote</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/fib/">Computing Fibonacci Numbers</a></li><li><a class="tocitem" href="../examples/pyramid/">Pyramid example</a></li><li><a class="tocitem" href="../examples/besselj/">Bessel function</a></li><li><a class="tocitem" href="../examples/sparse/">Sparse matrices</a></li><li><a class="tocitem" href="../examples/lognumber/">Logarithmic number system</a></li><li><a class="tocitem" href="../examples/unitary/">Unitary matrix operations without allocation</a></li><li><a class="tocitem" href="../examples/nice/">NICE network</a></li><li><a class="tocitem" href="../examples/realnvp/">RealNVP network</a></li><li><a class="tocitem" href="../examples/qr/">A simple QR decomposition</a></li><li><a class="tocitem" href="../examples/boxmuller/">Box-Muller method to Generate normal distribution</a></li></ul></li><li><span class="tocitem">API &amp; Manual</span><ul><li><a class="tocitem" href="../instructions/">Instruction Reference</a></li><li><a class="tocitem" href="../extend/">How to extend</a></li><li><a class="tocitem" href="../examples/sharedwrite/">The shared write problem on GPU</a></li><li><a class="tocitem" href="../api/">API Manual</a></li><li><a class="tocitem" href="../faq/">-</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>What and Why</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>What and Why</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/GiggleLiu/NiLang.jl/blob/master/docs/src/why.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="What-is-Reversible-Computing-and-why-do-we-need-it"><a class="docs-heading-anchor" href="#What-is-Reversible-Computing-and-why-do-we-need-it">What is Reversible Computing and why do we need it</a><a id="What-is-Reversible-Computing-and-why-do-we-need-it-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-Reversible-Computing-and-why-do-we-need-it" title="Permalink"></a></h1><h1 id="what-is-reversible-computing"><a class="docs-heading-anchor" href="#what-is-reversible-computing">what is reversible computing</a><a id="what-is-reversible-computing-1"></a><a class="docs-heading-anchor-permalink" href="#what-is-reversible-computing" title="Permalink"></a></h1><p>Reversible computing is a computing paradigm that can deterministically undo all the previous changes, which requires user not erasing any information during computations. It boomed during 1970-2005, however, but runs into a winter after that. The following book covers most of reversible computing that you want to know, especially the software part.</p><p><img src="../asset/revcomp.jpg" alt="Introduction to Reversible Computing"/></p><h2 id="Why-reversible-computing-is-the-future-of-computing:-a-physicist&#39;s-perspective"><a class="docs-heading-anchor" href="#Why-reversible-computing-is-the-future-of-computing:-a-physicist&#39;s-perspective">Why reversible computing is the future of computing: a physicist&#39;s perspective</a><a id="Why-reversible-computing-is-the-future-of-computing:-a-physicist&#39;s-perspective-1"></a><a class="docs-heading-anchor-permalink" href="#Why-reversible-computing-is-the-future-of-computing:-a-physicist&#39;s-perspective" title="Permalink"></a></h2><p>Reversible computing can do anything traditional computing can do. It can be simulated on a irreversible device, but sometimes need either more space or time or both. So, why are people still interested in reversible computing?</p><h3 id="From-the-energy-perspective"><a class="docs-heading-anchor" href="#From-the-energy-perspective">From the energy perspective</a><a id="From-the-energy-perspective-1"></a><a class="docs-heading-anchor-permalink" href="#From-the-energy-perspective" title="Permalink"></a></h3><p>Energy is one of the most important bottleneck of computation. Energy efficiency of computing devices affect the value of <a href="https://www.investopedia.com/news/do-bitcoin-mining-energy-costs-influence-its-price/">bitcoins</a>, user experiences of your cell phone, artificial intelligence (AI) industry.</p><p>Reversible computing devices are more energy efficiency, citing the famous <a href="https://en.wikipedia.org/wiki/Landauer%27s_principle">Landauer&#39;s principle</a></p><blockquote><p>Landauer&#39;s principle is a physical principle pertaining to the lower theoretical limit of energy consumption of computation. It holds that &quot;any logically irreversible manipulation of information, such as the erasure of a bit or the merging of two computation paths, must be accompanied by a corresponding entropy increase in non-information-bearing degrees of freedom of the information-processing apparatus or its environment&quot;.Another way of phrasing Landauer&#39;s principle is that if an observer loses information about a physical system, the observer loses the ability to extract work from that system.</p></blockquote><p>In the future, the building block of information technology is probably based on microscopic dynamics (e.g. cold atoms, DNA, quantum dot). Irreversibility is rare in these systems. Irreversible dynamics is available only in macroscopic world, where you assume the existence an infinite sized &quot;bath&quot;. For example, Like &quot;measure&quot; operation in quantum computing (a kind of reversible computing) is irreversible, as well as one of the slowest operation on quantum devices, one have to wait for the read out signal.</p><p>However, investors lost interest to reversible computing at around 2005 according to <a href="https://arxiv.org/abs/1803.02789">this paper</a> because energy efficiency of traditional CMOS is still approximately 2 orders above the Landauer&#39;s limit, there should still be a lot room to improve, while many reversible computing devices are not &quot;technical smooth&quot;. </p><p>Undoubtedly, traditional CMOS comes into the bottleneck of energy efficiency recent years. The reversible computing scheme adiabatic CMOS is technical smooth and shows orders more energy efficient than traditional CMOS, and it is <a href="https://www.osti.gov/servlets/purl/1377599">already useful in spacecrafts</a>. The detailed analysis of the energy-speed trade off in adiabatic CMOS can be found <a href="https://www3.nd.edu/~lent/pdf/nd/AdiabaticCMOS_HanninenSniderLent2014.pdf">here</a>.</p><h2 id="From-the-artificial-intelligence-perspective"><a class="docs-heading-anchor" href="#From-the-artificial-intelligence-perspective">From the artificial intelligence perspective</a><a id="From-the-artificial-intelligence-perspective-1"></a><a class="docs-heading-anchor-permalink" href="#From-the-artificial-intelligence-perspective" title="Permalink"></a></h2><p>In reversible programming, <a href="https://arxiv.org/abs/2003.04617">differentiable programming is directly achievable</a>. Notice most differentiable programming are built up of basic instructions like &quot;+&quot;, &quot;*&quot;, &quot;/&quot;, &quot;-&quot;. We can use these basic instructions to write Bessel functions, singular value decompositions et. al. Reversible programming allows you to define adjoint rules on instructions only, rather than defining a lot primitives. <strong>This timing is perfect because at this timing, AI is very popular with a lot amazing applications. It requires reversibility for AD, and it is also power consuming.</strong> In the past, most source to source AD frameworks are based checkpointing. Checkpointing is a naive version of reversible programming that caches everything into a global stack. Reversible programming provides us more flexibility.</p><h2 id="Embrace-Reversible-Computing:-Software-goes-first"><a class="docs-heading-anchor" href="#Embrace-Reversible-Computing:-Software-goes-first">Embrace Reversible Computing: Software goes first</a><a id="Embrace-Reversible-Computing:-Software-goes-first-1"></a><a class="docs-heading-anchor-permalink" href="#Embrace-Reversible-Computing:-Software-goes-first" title="Permalink"></a></h2><ol><li>Reversible hardwares relies on reversible software and compiling techniques.</li></ol><p>The inverse is not true. Reversible hardware is an energy efficient host for reversible programs.</p><ol><li>Reversible programming is already useful in machine learning, it is technical smooth to embrace reversible computing from the software side.</li></ol><h2 id="FAQ"><a class="docs-heading-anchor" href="#FAQ">FAQ</a><a id="FAQ-1"></a><a class="docs-heading-anchor-permalink" href="#FAQ" title="Permalink"></a></h2><p><strong>Q: does this compose with cudanative kernels? So we don&#39;t have to write custom adjoints?</strong></p><p>A: It is composible with KernelAbstraction, we have an example <a href="https://giggleliu.github.io/NiLang.jl/dev/examples/besselj/#CUDA-programming-1 ">here</a> For CUDAnative, the problem is the power operations ^ on GPU is not compatible with that on CPU. It can be solved, but needs some patch.</p><p>Still, I want to emphasis writing differentiable parallel kernels have the problem of share read in forward will become shared write when back propagating gradients, which produces wrong gradients. It is a known hard problem in combining CUDA programming and differential programming.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../tutorial/">My first NiLang program »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 22 April 2021 23:50">Thursday 22 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
